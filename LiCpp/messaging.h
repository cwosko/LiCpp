/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

//  Name: Messaging
//  Description:
//    This code is based on listing_c.1 to listing_c.5 from the book "C++ Concurrency in Action"
//    by Anthony Williams. For explanation refer to the above mentioned book.
//    Modifications are commented in the code itself. For questions contact cwo_at_zuehlke.com.

#ifndef MESSAGING_H_
#define MESSAGING_H_

#include <condition_variable>
#include <queue>
#include <memory>
#include <mutex>

namespace messaging {
  struct message_base {
    virtual ~message_base() {
    }
  };

  template<typename Msg>
  struct wrapped_message:
      message_base {
    Msg contents;
    explicit wrapped_message(Msg const& contents_):
      contents(contents_) {
    }
  };

  //  Class Empty Queue
  //    Marker and return value in case of an empty queue
  class empty_queue { };

  class queue {
      std::mutex m;
      std::condition_variable c;
      std::queue<std::shared_ptr<message_base> > q;
    public:
      template<typename T>
      void push(T const& msg) {
        std::lock_guard<std::mutex> lk(m);
        q.push(std::make_shared<wrapped_message<T> >(msg));
        c.notify_all();
      }
      std::shared_ptr<message_base> wait_and_pop() {
        std::unique_lock<std::mutex> lk(m);
        c.wait(lk,[&] {return !q.empty();});
        auto res=q.front();
        q.pop();
        return res;
      }

      //  Method Check and Pop
      //    Non-blocking method for checking for messages in the queue.
      //    If the queue is not empty, returns the front of the queue.
      //    If the queue is empty, returns Empty Queue marker.
      std::shared_ptr<message_base> check_and_pop() {
        std::unique_lock<std::mutex> lk(m);
        if (c.wait_for(lk,std::chrono::milliseconds(0),[&] {return !q.empty();})) {
          auto res=q.front();
          q.pop();
          return res;
        }
        else {
          empty_queue msg;
          return std::make_shared<wrapped_message<empty_queue> >(msg);
        }
      }

  };

  class sender {
      queue*q;
    public:
      sender():
        q(nullptr) {
      }
      explicit sender(queue*q_):
        q(q_) {
      }
      template<typename Message>
      void send(Message const& msg) {
        if(q) {
          q->push(msg);
        }
      }
  };

  template<typename RootDispatcher,typename PreviousDispatcher,typename Msg,typename Func,
           // Additonal template parameter IfFunc
           //   Enables to provide a Predicate function for checking message content before
           //   dispatching it.
           typename IfFunc=std::function<bool(Msg const& msg)> > 
  class TemplateDispatcher {
      queue* q;
      RootDispatcher* root;
      PreviousDispatcher* prev;
      Func f;

      // Predicate for checking message contents before dispatch
      IfFunc iff;

      bool chained;

      // Flag indicating blocking access to the message queue
      bool blocking;
      // Flag indicating usage of a Predicate before dispatch
      bool conditional;

      TemplateDispatcher(TemplateDispatcher const&)=delete;
      TemplateDispatcher& operator=(TemplateDispatcher const&)=delete;

      template<typename Root, typename Dispatcher,typename OtherMsg,typename OtherFunc,typename OtherIfFunc>
      friend class TemplateDispatcher;

      void wait_and_dispatch() {
        for(;;) {
          auto msg=q->wait_and_pop();
          if(dispatch(msg))
            break;
        }
      }

      //  Method Check and Dispatch
      //    Non-blocking method for dispatching messages.
      void check_and_dispatch() {
        auto msg=q->check_and_pop();
        dispatch(msg);
      }

      //  Method Handle Contents
      //    Call handler that does not require message contents
      template<typename F,typename R>
      void handle_contents(R (F::*mf)() const, Msg const& contents)
      {
          f();
      }

      //  Method Handle Contents (overload)
      //    Call handler that actually handles message contents
      template<typename F,typename R,typename A1>
      void handle_contents(R (F::*mf)(A1) const, Msg const& contents)
      {
          f(contents);
      }

      //  Method Dispatch
      //    Now also handling the conditional case using a Predicate.
      bool dispatch(std::shared_ptr<message_base> const& msg) {

        if(wrapped_message<Msg>* wrapper=
              dynamic_cast<wrapped_message<Msg>*>(msg.get())) {
          if (conditional) {
            if (iff(wrapper->contents)) {
              handle_contents(&Func::operator(), wrapper->contents);
              return true;
            } else {
              return prev->dispatch(msg);
            }
          } else {
            handle_contents(&Func::operator(), wrapper->contents);
            return true;
          }
        } else {
          return prev->dispatch(msg);
        }
      }

    public:
      TemplateDispatcher(TemplateDispatcher&& other):
        q(other.q), root(other.root), prev(other.prev), f(std::move(other.f)), iff(std::move(other.iff)), chained(other.chained), blocking(other.blocking), conditional(other.conditional) {
        other.chained=true;
      }

      TemplateDispatcher(queue* q_,RootDispatcher* root_,PreviousDispatcher* prev_,Func&& f_,IfFunc&& iff_,bool blocking_,bool conditional_):
        q(q_),root(root_),prev(prev_),f(std::forward<Func>(f_)),iff(std::forward<IfFunc>(iff_)), chained(false),blocking(blocking_),conditional(conditional_) {
        prev_->chained=true;
      }

      template<typename OtherMsg,typename OtherFunc>
      TemplateDispatcher<RootDispatcher,TemplateDispatcher,OtherMsg,OtherFunc>
      handle(OtherFunc&& of) {
        auto dummy_func = [](OtherMsg const& msg) {
          return false;
        };
        return TemplateDispatcher<
               RootDispatcher,TemplateDispatcher,OtherMsg,OtherFunc>(
                 q,root,this,std::forward<OtherFunc>(of),dummy_func,blocking,false);
      }

      //  Method Handle If
      //    Message handler function with conditional using a Predicate.
      template<typename OtherMsg, typename OtherIfFunc, typename OtherFunc>
      TemplateDispatcher<RootDispatcher,TemplateDispatcher,OtherMsg,OtherFunc,OtherIfFunc>
      handle_if(OtherIfFunc&& oiff, OtherFunc&& of) {
        return TemplateDispatcher<
               RootDispatcher,TemplateDispatcher,OtherMsg,OtherFunc,OtherIfFunc>(
                 q,root,this,std::forward<OtherFunc>(of),std::forward<OtherIfFunc>(oiff),blocking,true);
      }

      //  Method Handle Default
      //    Message handler function for handling the default case
      //    (no other handler kicked in before).
      template<typename DefaultFunc>
      void handle_default(DefaultFunc&& df) {
        root->set_default_handler(df);
      }

      ~TemplateDispatcher() noexcept(false) {
        if(!chained) {
          if (blocking)
            wait_and_dispatch();
          else
            check_and_dispatch();
        }
      }
  };

  class close_queue {
  };

  class dispatcher {
      queue* q;
      bool chained;
      bool blocking;
      std::function<void(std::shared_ptr<message_base> const& msg)> default_handler;

      dispatcher(dispatcher const&)=delete;
      dispatcher& operator=(dispatcher const&)=delete;

      template<
      typename Root,
               typename Dispatcher,
               typename Msg,
               typename Func,
               typename IfFunc>
      friend class TemplateDispatcher;

      void wait_and_dispatch() {
        for(;;) {
          auto msg=q->wait_and_pop();
          dispatch(msg);
        }
      }

      //  Method Check and Dispatch
      //    Non-blocking method for dispatching messages.
      void check_and_dispatch() {
        auto msg=q->check_and_pop();
        dispatch(msg);
      }

      bool dispatch(
        std::shared_ptr<message_base> const& msg) {
        if(dynamic_cast<wrapped_message<close_queue>*>(msg.get())) {
          // End blocking dispatch by throwing an exception (to be caught and ignored by caller)
          if (blocking)
            throw close_queue();
        }

        if (blocking && default_handler)
          default_handler(msg);

        return false;
      }
    public:
      dispatcher(dispatcher&& other):
        q(other.q),chained(other.chained),blocking(other.blocking),default_handler(other.default_handler) {
        other.chained=true;
      }

      explicit dispatcher(queue* q_, bool blocking_):
        q(q_),chained(false),blocking(blocking_),default_handler(NULL) {
      }

      template<typename Message,typename Func>
      TemplateDispatcher<dispatcher,dispatcher,Message,Func>
      handle(Func&& f) {
        auto dummy_func = [](Message const& msg) {
          return false;
        };
        return TemplateDispatcher<dispatcher,dispatcher,Message,Func>(
                 q,this,this,std::forward<Func>(f),dummy_func,blocking,false);
      }

      //  Method Handle If
      //    Message handler function with conditional using a Predicate.
      template<typename Message,typename IfFunc,typename Func>
      TemplateDispatcher<dispatcher,dispatcher,Message,Func,IfFunc>
      handle_if(IfFunc&& iff, Func&& f) {
        return TemplateDispatcher<dispatcher,dispatcher,Message,Func,IfFunc>(
                 q,this,this,std::forward<Func>(f),std::forward<IfFunc>(iff),blocking,true);
      }


      //  Method Set Default Handler
      //    Helper method for providing a default message handler
      //    that uses/accesses the message in question.
      void set_default_handler(std::function<void(std::shared_ptr<message_base> const& msg)> func) {
        default_handler = std::move(func);
      }

      //  Method Set Default Handler
      //    Helper method for providing a default message handler
      //    that ignores the message in question.
      void set_default_handler(std::function<void(void)> func) {
        default_handler = [=](std::shared_ptr<message_base> const& msg) {
          func();
        };
      }

      //  Destructor Method
      //    The real work starts here. Handles blocking and non-blocking case.
      ~dispatcher() noexcept(false) {
        if(!chained) {
          if (blocking)
            wait_and_dispatch();
          else
            check_and_dispatch();
        }
      }
  };

  class receiver {
      queue q;
    public:
      operator sender() {
        return sender(&q);
      }
      dispatcher wait() {
        return dispatcher(&q,true);
      }
      
      //  Method Check
      //    Non-blocking method for checking for and handling messages.
      dispatcher check() {
        return dispatcher(&q,false);
      }
      
      sender get_sender() {
        return sender(&q);
      }
  };
}


#endif /* MESSAGING_H_ */
