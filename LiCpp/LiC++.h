/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/


//  Name: LiC++ - Let it Crash in C++
//  Copyright: Boost Software License - Version 1.0 - August 17th, 2003
//  Author: Christoph Woskowski, cwo_at_zuehlke.com
//  Description:
//    This is a header only library, enabling to implement the Erlang "Let it Crash"
//    paradigm of handling errors in C++. It uses the Message Passing example from
//    the book "C++ Concurrency in Action" by Anthony Williams in order to allow
//    message based communication between threads. It also uses the Thread Safe List
//    example from the same book for managing threads in a thread register.
//    Basically this library enables to start, pause, resume and kill threads, while
//    allowing them to communication via message queues. It also allows to link
//    threads for monitoring purposes. If one thread is dying (getting killed or
//    killing itself by throwing an exception) the monitoring thread gets notified
//    and may react by replacing the dead one. See the following link for more
//    information regarding "Let it Crash" (LiC):
//    http://blog.zuehlke.com/en/is-it-safe-to-let-it-crash/

#ifndef LIC___H_
#define LIC___H_
#include "messaging.h"
#include "threadsafe_list.h"

#include <thread>
#include <cstdint>
#include <limits>


#include <iostream>

// CppDroid does not support exception pointers,
// so return a null pointer in this case.
#ifdef CPPDROID
typedef void* pException;
#define CURRENT_EXCEPTION (nullptr)
#else
typedef std::exception_ptr pException;
#define CURRENT_EXCEPTION (std::current_exception())
#endif

namespace LiCpp {

  // LiCpp uses the std::thread ID as a unique identifier of the managed threads / active objects
  typedef std::thread::id ThreadId;
  // A message box enables to transfer information between threads
  typedef std::shared_ptr<messaging::receiver> pMsgBox;
  // A thread can have an alias identifier, to be reachable independent of the currently running instance (thread ID)
  typedef uint8_t Alias;

  // Convention to mark an undefined alias
  static const Alias undefined_alias = std::numeric_limits<std::uint8_t>::max();
  // Forward declaration of the LiC++ Runtime
  class LiCppRuntime;

  //  Class Thread Register
  //    Manages the threads that are part of the LiC++ ecosystem.
  //    Enables to spawn, pause, resume and kill managed threads.
  //    Internally used by the LiC++ Runtime (see below).
  class ThreadRegister {
      friend class LiCppRuntime;

      // Internal message used for killing a thread
      struct msg_kill_thread {};
      // Internal message used for pausing a thread
      struct msg_suspend_thread {};
      // Internal message used for resuming a thread
      struct msg_resume_thread {};
      // Internal message used for shutting down everything
      struct msg_shutdown {};

    public:
      // Constructor
      ThreadRegister() : _register() {};

      // Destructor
      ~ThreadRegister() {
        // Finish remaining managed threads by closing the public message box,
        // sending the private shutdown message, waiting for end of execution (join)
        // and finally clearing the register entries.
        _register.for_each([&](RegisterEntry& entry) {
          if (entry.public_msg_box)
            entry.public_msg_box->get_sender().send(messaging::close_queue());
          entry.private_msg_box->get_sender().send(msg_shutdown());
          entry.std_thread.join();
        });
        _register.remove_if([&](const RegisterEntry& entry) {
          return true;
        });
      }

    private:

      //  Struct Register Entry
      //    A thread register entry holds all information required for managing
      //    one specific thread.
      typedef struct RegEntry {
        RegEntry(ThreadId thread_id_, std::thread&& std_thread_, pMsgBox private_msg_box_,
                 pMsgBox public_msg_box_, Alias alias_ = undefined_alias):
          thread_id(thread_id_), std_thread(std::move(std_thread_)), supervisor_id(),
          private_msg_box(private_msg_box_), public_msg_box(public_msg_box_), alias(alias_) {};

        // Unique identifier of the managed thread
        ThreadId thread_id;
        // The managed standard thread itself
        std::thread std_thread;
        // Unique identifier of the monitoring thread
        ThreadId supervisor_id;
        // Message box solely used for internal messages to the managed thread
        pMsgBox private_msg_box;
        // Message box solely used for public messages to the managed thread
        pMsgBox public_msg_box;
        // Alias identifier of the managed thread
        Alias alias;
      } RegisterEntry;

      typedef std::shared_ptr<RegisterEntry> pRegisterEntry;

      //  Method Add Thread
      //    Adds a newly created thread to be managed to the register and links the currently running thread as supervisor
      //    Requires the thread itself, the private and public message boxes and optionally an alias identifier.
      //    Returns the thread ID of the added thread.
      ThreadId add_thread(std::thread&& std_thread, pMsgBox private_msg_box, pMsgBox public_msg_box, Alias alias = undefined_alias) {
        ThreadId thread_id = std_thread.get_id();
        _register.push_front({thread_id,std::move(std_thread),private_msg_box,public_msg_box, alias});
        return thread_id;
      }

      //  Method Add Existing (Thread)
      //    Adds an already running thread to the register in order to make it available and addressable for messaging.
      //    Requires the thread ID of the existing thread, a private message box and an optional public message box.
      void add_existing(ThreadId thread_id, pMsgBox private_msg_box, pMsgBox public_msg_box = nullptr) {
        _register.push_front({thread_id,std::move(std::thread()),private_msg_box,public_msg_box});
      }

      //  Method Kill Thread
      //    First part of finishing a thread by closing the public message box
      //    and sending the private kill message.
      //    Requires the unique thread ID of the thread to be killed.
      void kill_thread(ThreadId id) {
        _register.for_each([&](RegisterEntry& entry) {
          if (id == entry.thread_id) {
            if (entry.public_msg_box)
              entry.public_msg_box->get_sender().send(messaging::close_queue());
            entry.private_msg_box->get_sender().send(msg_kill_thread());
          }
        });
      }

      //  Method Remove Thread
      //    Second part of finishing a thread by waiting for end of execution (join)
      //    and finally clearing the register entry.
      //    Requires the unique thread ID of the thread to be removed.
      void remove_thread(ThreadId id) {
        _register.for_each([&](RegisterEntry& entry) {
          if (id == entry.thread_id)
            entry.std_thread.join();
        });
        unregister_thread(id);
      }

      //  Method Unregister Thread
      //    Clears the register entry of a thread, making it unreachable via messaging.
      //    Requires the unique thread ID of the thread to be unregistered.
      void unregister_thread(ThreadId id) {
        _register.remove_if([&](const RegisterEntry& entry) {
          return (id == entry.thread_id);
        });
      }

      //  Method Send Private (Message)
      //    Sends a message to the private message queue of a thread.
      //    This is only used internally for transmitting control commands.
      //    Requires the unique thread ID of the receiving thread and the message to be sent.
      template<typename Message>
      void send_private(ThreadId id, Message const& msg) {
        _register.for_each([&](RegisterEntry& entry) {
          if (id == entry.thread_id)
            entry.private_msg_box->get_sender().send(msg);
        });
      }

      //  Method Send Public (Message)
      //    Sends a message to the public message queue of a thread.
      //    This is only used for user defined messages.
      //    Requires the unique thread ID of the receiving thread and the message to be sent.
      template<typename Message>
      void send_public(ThreadId id, Message const& msg) {
        _register.for_each([&](RegisterEntry& entry) {
          if (id == entry.thread_id)
            entry.public_msg_box->get_sender().send(msg);
        });
      }

      //  Method Send (Public Message) to Alias
      //    Sends a message to the public message queue of a thread.
      //    This is only used for user defined messages.
      //    Requires the alias identifier of the receiving thread(s)  and the message to be sent.
      template<typename Message>
      void send_alias(Alias alias, Message const& msg) {
        _register.for_each([&](RegisterEntry& entry) {
          if (alias == entry.alias)
            entry.public_msg_box->get_sender().send(msg);
        });
      }

      //  Method Send (Public) Broadcast (Message)
      //    Sends a message to the public message queue of all managed threads.
      //    This is only used for user defined messages.
      //    Requires the message to be sent as broadcast.
      template<typename Message>
      void send_broadcast(Message const& msg) {
        _register.for_each([&](RegisterEntry& entry) {
          if (entry.public_msg_box)
            entry.public_msg_box->get_sender().send(msg);
        });
      }

      //  Method Link Thread To Supervisor
      //    Establishes a link between a thread and its monitoring thread (Supervisor)
      //    The supervisor will be informed in case of thread termination.
      //    Requires the unique IDs of the thread to be monitored and its supervisor.
      void link_thread_to_supervisor(ThreadId id, ThreadId supervisor_id) {
        _register.for_each([&](RegisterEntry& entry) {
          if (id == entry.thread_id)
            entry.supervisor_id = supervisor_id;
        });
      }

      //  Method Send (Message) To Supervisor Of Thread
      //    Sends a message to the public message queue of the supervisor of a thread.
      //    This is only used internally for sending the crash message to the supervisor.
      //    Requires the unique thread ID of a thread with a supervisor and the message to be sent.
      template<typename Message>
      void send_to_supervisor_of_thread(ThreadId id, Message const& msg) {
        pRegisterEntry pEntry = _register.find_first_if([&](const RegisterEntry& entry) {
          return (id == entry.thread_id);
        });
        if (pEntry != pRegisterEntry()) {
          send_public(pEntry->supervisor_id, msg);
        }
      }

      //  Method Suspend Thread
      //    Sends a suspend message to the private message queue of a thread, causing it to
      //    break and wait for a resume message. Recursively pauses supervisors first.
      //    Requires the unique thread ID of a thread to pause.
      void suspend_thread(ThreadId id) {
        _register.for_each([&](RegisterEntry& entry) {
          if (id == entry.supervisor_id)
            suspend_thread(entry.thread_id);
        });
        send_private(id,msg_suspend_thread());
      }

      //  Method Resume Thread
      //    Sends a resume message to the private message queue of a thread, causing a
      //    suspended thread to resume. Recursively resumes supervisors afterwards.
      //    Requires the unique thread ID of a thread to resume.
      void resume_thread(ThreadId id) {
        send_private(id,msg_resume_thread());
        _register.for_each([&](RegisterEntry& entry) {
          if (id == entry.supervisor_id)
            resume_thread(entry.thread_id);
        });
      }

      //  Method Get (public) Message Box
      //    Access public message box of a thread, e.g. for adding message handling
      //    to a thread. Requires the unique thread ID of a thread to pause.
      //    Returns a shared pointer to the message box.
      pMsgBox get_msg_box(ThreadId id) {
        pRegisterEntry pEntry = _register.find_first_if([&](const RegisterEntry& entry) {
          return (id == entry.thread_id);
        });
        if (pEntry != pRegisterEntry()) {
          if (pEntry->public_msg_box)
            return pEntry->public_msg_box;
        }
        return nullptr;

      }

      //  Method (Is) Thread Registered
      //    Checks whether a thread is currently managed by the LiC library or not.
      //    Requires the unique thread ID of the thread to search for in the register.
      //    Returns true if the thread is known to LiC lib, false otherwise.
      bool thread_registered(ThreadId id) {
        pRegisterEntry pEntry = _register.find_first_if([&](const RegisterEntry& entry) {
          return (id == entry.thread_id);
        });
        return (pEntry != pRegisterEntry());
      }

      //  Method List Threads
      //    Returns a vector of the thread IDs currently managed by the LiC library.
      std::vector<ThreadId> list_threads() {
        std::vector<ThreadId> thread_list;
        _register.for_each([&](RegisterEntry& entry) {
          thread_list.push_back(entry.thread_id);
        });
        return thread_list;
      }

      //  Method (Get) Thread ID from Alias
      //    Method for determining the thread ID corresponding to an alias.
      //    Requires the alias name of the thread to search for.
      //    Returns the first thread ID that corresponds to that alias name
      //    or ThreadId() if no thread has been found.
      ThreadId thread_id_from_alias(Alias alias) {
        pRegisterEntry pEntry = _register.find_first_if([&](const RegisterEntry& entry) {
          return (alias == entry.alias);
        });
        if (pEntry != pRegisterEntry()) {
          return pEntry->thread_id;
        }
        return ThreadId();
      }

      //  Thread safe list that contains the actually registered threads.
      threadsafe_list<RegisterEntry> _register;
  };

  //  Typedef for pointer to thread register.
  typedef std::shared_ptr<ThreadRegister> pThreadRegister;

  //  Internal message for carrying information about a crashed / terminated crash
  struct msg_crash {
    //  ID of the terminated thread
    ThreadId id;
    //  Pointer to the exception that finished the thread.
    pException exc_ptr;
    //  Constructor of the crash message initializing the payload
    msg_crash(ThreadId id_, pException exc_ptr_):id(id_),exc_ptr(exc_ptr_) {};
  };

  //  Internal message for informing about an unexpected finish of a thread, that
  //  was not caused by an exception but an unexpected exit of the thread loop.
  struct msg_unexpected_finish {
    // ID of the unexpectedly finished thread
    ThreadId id;
    // Constructor of the unexpected finish message initializing the payload
    msg_unexpected_finish(ThreadId id_):id(id_) {};
  };


  //  Class LiC++ Runtime
  //    Actual runtime environment for using the LiC paradigm in C++.
  //    Provides functionality for spawning managed threads, for linking worker and
  //    supervisor threads and for messaging between managed threads. Internally
  //    uses the thread register class (see above) to manage threads.
  class LiCppRuntime {
  
      //  Internal exception used for killing single managed threads.
      class kill_thread_exception {};
      //  Internal exception used for a clean shutdown of all managed threads.
      class shutdown_exception {};

    public:
    
      //  Typedef defining the signature of a (global) crash handler
      typedef std::function<void(ThreadId, pException)> CrashHandler;
      
      //  Constructor
      LiCppRuntime()
        :_incoming(), _thread_register(std::make_shared<ThreadRegister>()), _crash_handler(nullptr) {};

      //  Destructor
      ~LiCppRuntime() {
        _crash_handler = nullptr;
        //  No cleanup here, the thread register takes care of it 
      }

      //  Method Spawn Looping (Thread)
      //    Spawns a "looping" thread by running a provided function containing a 
      //    main loop in a new thread. Enables control of the thread (pause, resume,
      //    kill) by adding a private message queue. Requires the function to be executed
      //    to take a interruption-check-function of type std::function<void()> as first 
      //    parameter and to call this interruption check in its main loop. Further 
      //    arguments are simply forwarded. 
      //    Returns the unique thread ID of the created managed thread.      
      template <class Fn, class... Args>
      ThreadId spawn_looping(Fn&& looping_func, Args&&... args) {
        pMsgBox private_receiver = std::make_shared<messaging::receiver>();
        std::function<void()> interruption_check = [=]() {
          interruption_fun(private_receiver);
        };
        std::thread spawned_thread = std::thread(
                                       &LiCppRuntime::looping_thread, this,
                                       static_cast< std::function<void()> >(std::bind(std::forward<Fn>(looping_func),interruption_check,std::forward<Args>(args)...)));
        return _thread_register->add_thread(std::move(spawned_thread), private_receiver, nullptr);
      }

      //  Method Spawn Cyclic (Thread)
      //    Spawns a "cyclic" thread by cyclically calling a provided function from a newly
      //    created thread. Enables control of the thread (pause, resume, kill) by adding 
      //    a private message queue. Requires the cyclic thread function and its arguments
      //    (may be zero), which will be forwarded. 
      //    Returns the unique thread ID of the created managed thread. 
      template <class Fn, class... Args>
      ThreadId spawn_cyclic(Fn&& cyclic_func, Args&&... args) {
        pMsgBox private_receiver = std::make_shared<messaging::receiver>();
        std::thread spawned_thread = std::thread(
                                       &LiCppRuntime::cyclic_thread, this,
                                       static_cast< std::function<void()> > (std::bind(std::forward<Fn>(cyclic_func),std::forward<Args>(args)...)),
                                       private_receiver);
        return _thread_register->add_thread(std::move(spawned_thread), private_receiver, nullptr);
      }

      //  Method Spawn Messaging (Thread)
      //    Spawn a "messaging" thread by cyclically calling a provided function from a newly
      //    created thread. Enables control of the thread (pause, resume, kill) by adding
      //    a private message queue and messaging by adding a public message queue. Requires the
      //    cyclic thread function to be called taking a shared pointer to a "thread-local" storage
      //    as an argument. Requires also the initial state of the thread storage (to be forwarded).
      //    Optionally assigns the provided alias name.
      //    Returns the unique thread ID of the created managed thread.
      template<class ThreadStorage>
      ThreadId spawn_messaging(std::function<void(pMsgBox,std::shared_ptr<ThreadStorage>)> msg_handler, const ThreadStorage&& initial_storage, Alias alias = undefined_alias) {
        pMsgBox private_receiver = std::make_shared<messaging::receiver>();
        pMsgBox public_receiver = std::make_shared<messaging::receiver>();
        std::shared_ptr<ThreadStorage> storage = std::make_shared<ThreadStorage>(std::move(initial_storage));
        std::thread spawned_thread = std::thread(
                                       &LiCppRuntime::cyclic_thread, this,
                                       static_cast< std::function<void()> > (std::bind(msg_handler,public_receiver,storage)),
                                       private_receiver);
        return _thread_register->add_thread(std::move(spawned_thread), private_receiver, public_receiver, alias);
      }

      //  Method Spawn Messaging (Thread) (overload)
      //    Spawn a "messaging" thread by cyclically calling a provided function from a newly
      //    created thread. Enables control of the thread (pause, resume, kill) by adding
      //    a private message queue and messaging by adding a public message queue. Requires the
      //    cyclic thread function to be called. Optionally assigns the provided alias name.
      //    Returns the unique thread ID of the created managed thread.
      ThreadId spawn_messaging(std::function<void(pMsgBox)> msg_handler, Alias alias = undefined_alias) {
        pMsgBox private_receiver = std::make_shared<messaging::receiver>();
        pMsgBox public_receiver = std::make_shared<messaging::receiver>();
        std::thread spawned_thread = std::thread(
                                       &LiCppRuntime::cyclic_thread, this,
                                       static_cast< std::function<void()> > (std::bind(msg_handler,public_receiver)),
                                       private_receiver);
        return _thread_register->add_thread(std::move(spawned_thread), private_receiver, public_receiver, alias);
      }

      //  Method Add Messaging to Thread
      //    Adds a public and a private message queue to an existing thread and puts it into
      //    the managed list. Caution: Thread cannot be controlled by the LiC framework, the
      //    user has to stop the thread on shutdown. Requires the unique thread ID of the thread
      //    to add messaging to.
      void add_messaging_to_thread(ThreadId thread_id) {
        pMsgBox private_receiver = std::make_shared<messaging::receiver>();
        pMsgBox public_receiver = std::make_shared<messaging::receiver>();
        _thread_register->add_existing(thread_id, private_receiver, public_receiver);
      }

      //  Method Execute Blocking (Message Handler)
      //    Executes a blocking message handler within a messaging enabled thread (see above)
      //    for handling public messages sent to this very thread. Requires the unique ID of
      //    the current thread and a message handler function taking a pointer to a message box
      //    as an argument.
      void execute_blocking(ThreadId thread_id, std::function<void(pMsgBox)> msg_handler) {
        pMsgBox public_msg_box = _thread_register->get_msg_box(thread_id);
        if (public_msg_box)
          msg_handler(public_msg_box);
      }

      //  Method Remove Messaging from Thread
      //    Removes messaging from a thread that has been enabled to receive messages by
      //    the methods described above. Closes the public message queue and removes the thread
      //    from the register. Requires the unique ID of the thread to be unregistered.
      void remove_messaging_from_thread(ThreadId thread_id) {
        pMsgBox public_msg_box = _thread_register->get_msg_box(thread_id);
        if (public_msg_box)
          public_msg_box->get_sender().send(messaging::close_queue());
        _thread_register->unregister_thread(thread_id);
      }
      
      //  Method Register (global) Crash Handler
      //    Enables to register a global crash handler, that is called, whenever any managed
      //    thread crashes or gets called. Requires a crash handler function to be called taking
      //    a thread ID (crashed thread) and an exception pointer (crash reason) as arguments.
      void register_crash_handler(CrashHandler crash_handler) {
        _crash_handler = crash_handler;
      }

      //  Method Exec
      //    Global internal message handler of the franework to be called cyclically by the
      //    main program. Handles internal messages required for updating the thread register
      //    when threads have to be removed. This is the required secound step of killing
      //    a managed thread.
      void exec() {
        _incoming.check()
        .handle<msg_crash>(
        [&](msg_crash const& msg) {
          _thread_register->remove_thread(msg.id);
        }
        )
        .handle<msg_unexpected_finish>(
        [&](msg_unexpected_finish const& msg) {
          _thread_register->remove_thread(msg.id);
        }
        );
      }

      //  Method Kill Thread
      //    Triggers killing a thread by initiating the first part of finishing a thread.
      //    The secound step then is done by the Exec method above.
      //    Requires the unique thread ID of the thread to be killed.
      void kill_thread(ThreadId id) {
        _thread_register->kill_thread(id);
      }

      //  Method Send (Public) Message
      //    Sends a message to the public message queue of a thread.
      //    Requires the unique thread ID of the receiving thread and the message to be sent.
      template<typename Message>
      void send_message(ThreadId id, Message const& msg) {
        _thread_register->send_public(id, msg);
      }

      //  Method Send (Public) Broadcast (Message)
      //    Sends a message to the public message queue of all managed threads.
      //    Requires the message to be sent as broadcast.
      template<typename Message>
      void send_broadcast(Message const& msg) {
        _thread_register->send_broadcast(msg);
      }
      

      //  Method Send (Public Message) to Alias
      //    Sends a message to the public message queue of a thread.
      //    Requires the alias identifier of the receiving thread(s) and the message to be sent.
      template<typename Message>
      void send_to_alias(Alias alias, Message const& msg) {
        _thread_register->send_alias(alias, msg);
      }

      //  Method Link Thread To Supervisor
      //    Establishes a link between a thread and its monitoring thread (Supervisor)
      //    The supervisor will be informed in case of thread termination.
      //    Requires the unique IDs of the thread to be monitored and its supervisor.
      void link_thread_to_supervisor(ThreadId id, ThreadId supervisor_id) {
        _thread_register->link_thread_to_supervisor(id, supervisor_id);
      }

      //  Method Suspend Thread
      //    Suspends a thread, causing it to break and wait for a resume message.
      //    Recursively pauses supervisors first.
      //    Requires the unique thread ID of a thread to pause.
      void suspend_thread(ThreadId id) {
        _thread_register->suspend_thread(id);
      }

      //  Method Resume Thread
      //    Resumes a suspended thread. Recursively resumes supervisors afterwards.
      //    Requires the unique thread ID of a thread to resume.
      void resume_thread(ThreadId id) {
        _thread_register->resume_thread(id);
      }

      //  Method (Is) Thread Registered
      //    Checks whether a thread is currently managed by the LiC library or not.
      //    Requires the unique thread ID of the thread to search for in the register.
      //    Returns true if the thread is known to LiC lib, false otherwise.
      bool thread_registered(ThreadId id) {
        return _thread_register->thread_registered(id);
      }

      //  Method (Get) Current Thread ID
      //    Thin wrapper around the standard get ID function. Allows to replace the
      //    thread ID in future versions, if necessary.
      //    Returns the unique thread ID of the caller.
      ThreadId current_thread_id() {
        return std::this_thread::get_id();
      }

      //  Method List Threads
      //    Returns a vector of the thread IDs currently managed by the LiC++ library.
      std::vector<ThreadId> list_threads() {
        return _thread_register->list_threads();
      }

    private:
      //  Method Get Sender
      //    Thin wrapper enhancing readability.
      //    Returns the sender side of the global LiC++ runtime message queue.
      messaging::sender get_sender() {
        return _incoming;
      }

      //  Method Get Current Exception
      //    Thin wrapper of a system function for exception forwarding.
      //    Returns a pointer to the current exception if supported
      //    and a null pointer otherwise.
      pException get_current_exception() {
        return CURRENT_EXCEPTION;
      }

      //  Method Looping Thread
      //    Wrapper around an endless looping function provided by the caller,
      //    that enables to handle crashes (namely uncaught exceptions) or an
      //    unexpected finish of the loop.
      //    Requires the looping function to be called
      void looping_thread(std::function<void()> task) {
        ThreadId this_id = std::this_thread::get_id();
        try {
          // call the user function
          task();
          get_sender().send(msg_unexpected_finish(this_id));
        } catch (shutdown_exception const&) {
          // do nothing here, just quit ...
        } catch (...) {
          // notify global crash handler, supervisor and LiC++ runtime about the crash
          if (_crash_handler) _crash_handler(this_id, get_current_exception());
          _thread_register->send_to_supervisor_of_thread(this_id, msg_crash(this_id, get_current_exception()));
          get_sender().send(msg_crash(this_id, get_current_exception()));
        };
      }

      //  Method Cyclic Thread
      //    Provides an endless loop, which cyclically calls the user function.
      //    Enables to handle crashes (namely uncaught exceptions).
      //    Requires the function to by cyclically called and a pointer to the
      //    private message queue of the corresponding managed thread.
      void cyclic_thread(std::function<void()> task, pMsgBox incoming) {
        ThreadId this_id = std::this_thread::get_id();
        try {
          for (;;) {
            // handle possible interruptions
            interruption_fun(incoming);
            try {
              // call the user function
              task();
            } catch (messaging::close_queue const&) {
              // nothing to do here, potentially blocking queue is closed already ...
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(10));
          }
        } catch (shutdown_exception const&) {
          // do nothing here, just quit ...
        } catch (...) {
          // notify global crash handler, supervisor and LiC++ runtime about the crash
          if (_crash_handler) _crash_handler(this_id, get_current_exception());
          _thread_register->send_to_supervisor_of_thread(this_id, msg_crash(this_id, get_current_exception()));
          get_sender().send(msg_crash(this_id, get_current_exception()));
        };
      }

      //  Method Interruption Function
      //    Function placed within the user code (directly in cyclic thread, as parameter to be called
      //    in looping thread) for checking the private message queue for possible interruptions
      //    (pause, resume, kill, shutdown) and for reacting accordingly.
      //    Requires the private message queue of the corresponding managed thread.
      void interruption_fun(pMsgBox incoming) {
        bool do_block = false;
        // Non-blocking check for messages.
        incoming->check()
        // Handle shutdown message by throwing
        .handle<ThreadRegister::msg_shutdown>(
        [&](ThreadRegister::msg_shutdown const& msg) {
          throw shutdown_exception();
        }
        )
        // Handle kill message by throwing
        .handle<ThreadRegister::msg_kill_thread>(
        [&](ThreadRegister::msg_kill_thread const& msg) {
          throw kill_thread_exception();
        }
        )
        // Handle suspend message by blocking
        .handle<ThreadRegister::msg_suspend_thread>(
        [&](ThreadRegister::msg_suspend_thread const& msg) {
          // block on messages from now on
          do_block = true;
        }
        );
        if (do_block) {
          // Blocking wait for messages.
          incoming->wait()
          // Handle shutdown message by throwing
          .handle<ThreadRegister::msg_shutdown>(
          [&](ThreadRegister::msg_shutdown const& msg) {
            throw shutdown_exception();
          }
          )
          // Handle kill message by throwing
          .handle<ThreadRegister::msg_kill_thread>(
          [&](ThreadRegister::msg_kill_thread const& msg) {
            throw kill_thread_exception();
          }
          )
          // Handle resume message by unblocking
          .handle<ThreadRegister::msg_resume_thread>(
          [&](ThreadRegister::msg_resume_thread const& msg) {
            // just resume
          }
          );
        } else
          // nothing in the queue, allow other threads to run
          std::this_thread::yield();
      }

      //  Private message queue of the LiC++ runtime
      messaging::receiver _incoming;
      //  Pointer to the register of managed threads
      pThreadRegister _thread_register;
      //  Global crash handler
      CrashHandler _crash_handler;
  };

  // Typedef of a shared pointer to the LiC++ runtime
  typedef std::shared_ptr<LiCppRuntime> pLiCppRuntime;
}

#endif /* LIC___H_ */
