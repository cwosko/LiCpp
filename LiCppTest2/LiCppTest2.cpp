/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/


//  Name: LiC++ - Let it Crash in C++ - Worker/Supervisor Tests
//  Copyright: Boost Software License - Version 1.0 - August 17th, 2003
//  Author: Christoph Woskowski, cwo_at_zuehlke.com
//
//  Description:
//    This file contains some basic tests of the LiC++ runtime. Worker and
//    Supervisor are created and linked. The worker dies after some ticks
//    and gets restarted by the Supervisor. Both threads are paused, resumed
//    and finally killed.

#include "LiC++.h"

#include <iostream>
#include <atomic>

using namespace std;
using namespace LiCpp;

class Worker {
  public:
    static ThreadId CreateAndRun(pLiCppRuntime p_run, int initial_count) {
      ThreadId my_id = p_run->spawn_messaging<Worker>(Worker::msg_handler, Worker());
      p_run->send_message(my_id, msg_tick(initial_count));
      return my_id;
    }

  private:
    Worker() {
    };
    static void msg_handler(pMsgBox incoming, shared_ptr<Worker> me) {
      incoming->wait()
      .handle<msg_tick>(
      [&](msg_tick const& msg) {
        this_thread::sleep_for(chrono::milliseconds(100));
        if (msg.counter < 1) {
          cout << "boom" << endl;
          throw runtime_error("boom");
        }
        cout << "tick" << endl;
        incoming->get_sender().send(msg_tick(msg.counter - 1));
      }
      );
    };

    struct msg_tick {
      int counter;
      msg_tick(int counter_):counter(counter_) {};
    };
};

class SuperVisor {
  public:
    static ThreadId CreateAndRun(pLiCppRuntime p_run) {
      ThreadId my_id = p_run->spawn_messaging<SuperVisor>(SuperVisor::msg_handler, SuperVisor(p_run));
      p_run->send_message(my_id, msg_init(my_id));
      return my_id;
    }

  private:
    SuperVisor(pLiCppRuntime p_run) : _p_run(p_run) {
    }

    static void msg_handler(pMsgBox incoming, shared_ptr<SuperVisor> me) {
      incoming->wait()
      .handle<msg_init>(
      [&](msg_init const& msg) {
        me->_own_id = msg.id;
        ThreadId worker_id = Worker::CreateAndRun(me->_p_run, 20);
        me->_p_run->link_thread_to_supervisor(worker_id, me->_own_id);
      }
      )
      .handle<msg_crash>(
      [&](msg_crash const& msg) {
        ThreadId worker_id = Worker::CreateAndRun(me->_p_run, 20);
        me->_p_run->link_thread_to_supervisor(worker_id, me->_own_id);
      }
      );
    };

    ThreadId _own_id;
    pLiCppRuntime _p_run;
    struct msg_init {
      ThreadId id;
      msg_init(ThreadId id_):id(id_) {};
    };
};


int main()
{
  try {
    pLiCppRuntime p_run = make_shared<LiCppRuntime>();
    ThreadId sv_id = SuperVisor::CreateAndRun(p_run);

    atomic<bool> test_done(false);
    thread test_thread([&]() {
      this_thread::sleep_for(chrono::seconds(5));
      p_run->suspend_thread(sv_id);
      this_thread::sleep_for(chrono::seconds(3));
      p_run->resume_thread(sv_id);
      this_thread::sleep_for(chrono::seconds(3));
      p_run->kill_thread(sv_id);
      this_thread::sleep_for(chrono::seconds(5));
      test_done=true;
    });

    while(!test_done) {
      p_run->exec();
      this_thread::sleep_for(chrono::milliseconds(10));
    }

    test_thread.join();
    cout << "Game over!" << endl;
  } catch (exception& e) {
    cout << e.what() << endl;
  }
  return 0;
}
